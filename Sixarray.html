<canvas id="screen" width="480" height="400"/>


<script>
var screen = document.getElementById('screen');
var canvas = screen.getContext('2d');
setInterval(Main, 500); 


//Try These
//22A1A1pXdXX


//MIM Pointer: Moving-In-Memory Pointer





//E: Ends the script
//e: Restarts the script

//(number): Used to store data and move through the script.

//N (aka []): Stores abnormally large numbers.
//n: Stores numbers of a maximum size. (NYI)


//R: random, 1-3, it can be used in adding (NYI)
//r: jump ahead random, min previous number, max next number. (NYI)

//W: stops any jump going into the space (number in front) numbers ahead of it (NYI)
//w: like above but with the number behind (NYI)

//S: stop; stops the thread without ending it (NYI)

//X: placeholder

//C: copies from thread below at same index to nearest X
//c: copies from thread below at index (number in front) further from c's index to nearest X (NYI)


//P: "PUSH"es thing behind to the index of the thing in front in front of the P (NYI)
//p: "PUSH"es character in front to nearest X (NYI)

//G: "GIVE"s the thing behind to the index of the thing in front of the P... in the next thread (NYI)
//g: Moves the character behind this to the thread below's nearest X (NYI)

//D: sets character in front to X
//d: sets character behind to X

//F: declare function (number in front), put in parenthesis () (NYI)
//f: run function (number in front) (NYI)
//~: get num in front of function (NYI)
//`: get num behind function (NYI)
//I: Inject function (num in front) to index (num behind) in front of the I (NYI)
//i: Inject function (num in front) to index (num behind) in front of the I in the next thread (NYI)
//function injection copies the function and physically places it inside the list

//?: if number in front equals number behind, jump ahead 3, else jump 2 (NYI)

//>: if number in front is greater than number behind, jump ahead 3, else jump 2 (NYI)

//<: if number in front is less than number behind, jump ahead 3, else jump 2 (NYI)

//P: pushes thing behind to nearest X  (NYI)
//p: pushes thing in front to next thread's nearest X (NYI)

//-: wait time (number behind) (NYI)

//H: Unpackages Bracket Number in front (NYI)
//h: packages a bracket number with the numbers in front of (number behind) size (NYI)

//\: reverses MIM direction LIKE A BOSS (NYI)
//_: ROTATES THE DIRECTION THE FRICKING MIM DIRECTION BY 90 DEGREES LOLOL TIME TO GO 2D (NYI)

//M: Move to (number behind) in list
//m: Move (number in front) back in the list

console.log("answer="+(-1%6))
var Threads = []
var Indexes = []
function DecGet(sept)
{
	var out = 0;
	septagesimal = false
	if (sept < 10)
	{
		septagesimal = [sept]
	}
	else if (typeof sept == "object")
	{
		if (sept[0] == "N")
		{
			septagesimal = sept[1]
		}
		else
		{
			septagesimal = sept
		}
	}
	if (septagesimal != false)
	{
		for (var i = septagesimal.length - 1; i >= 0; i = i - 1)
		{
			out = out + septagesimal[i] * Math.pow(7,(septagesimal.length - 1 - i))
		}
	}
	return out;
}
function SeptGet(decimal)
{
	return parseInt(decimal, 10).toString(7).split('')
}
function Main() {
	requestAnimationFrame(draw)
	var RemoveThese = []
	for (var T = 0; T < Threads.length; T++)
	{
		done = false
		for (var v = 0; v < Threads[T].length; v++)
		{
			if (Threads[T][v] > 6)
			{
				Threads[T][v] = Threads[T][v] % 6;	
			}
		}
		i = Indexes[T]
		ok = Threads[T][i]
		if (typeof Threads[T][i] == "object")
		{
			if (Threads[T][i][0] == "N")
			{
				Indexes[T] = Indexes[T] + DecGet(Threads[T][i]);
			} 
		}
		else if (Threads[T][i] == 0)
		{
			Indexes[T] = Indexes[T] + 1;
		}
		else if (Threads[T][i] == 1)
		{
			Indexes[T] = Indexes[T] + 1;
		}
		else if (Threads[T][i] == 2)
		{
			Indexes[T] = Indexes[T] + 2;
		}
		else if (Threads[T][i] == 3)
		{
			Indexes[T] = Indexes[T] + 3;
		}
		else if (Threads[T][i] == 4)
		{
			Indexes[T] = Indexes[T] + 4;
		}
		else if (Threads[T][i] == 5)
		{
			Indexes[T] = Indexes[T] + 5;
		}
		else if (Threads[T][i] == 6)
		{
			Indexes[T] = Indexes[T] + 6;
		}
		else
		{				
			if (Threads[T][i] == "E")
			{
				done = true
			}
			if (Threads[T][i] == "e")
			{
				Indexes[T] = 0
			}
			if (Threads[T][i] == "D")
			{
				Threads[T][(i + 1) % Threads[T].length] = "X"
			}
			if (Threads[T][i] == "d")
			{
				ind = i - 1
				if (ind < 0)
				{
					ind = ind + Threads[T].length
				}
				Threads[T][(ind) % Threads[T].length] = "X"
			}
			if (Threads[T][i] == "a")
			{
				var go = false
				ind = i - 1
				if (ind < 0)
				{
					ind = ind + Threads[T].length
				}
				if (typeof Threads[T][(ind) % Threads[T].length] == "object")
				{
					if (Threads[T][(ind) % Threads[T].length][0] == "N")
					{
						go = true
					}
				}

				if (Threads[T][(ind) % Threads[T].length] < 7 || go)
				{
					if (Threads[T][(i + 1) % Threads[T].length] < 7)
					{
						Threads[T][(i + 1) % Threads[T].length] = DecGet(Threads[T][(i + 1) % Threads[T].length]) + DecGet(Threads[T][(ind) % Threads[T].length]);
					}
					if (typeof Threads[T][(i + 1) % Threads[T].length] == "object")
					{
						if (Threads[T][i+1][0] == "N")
						{
							Threads[T][(i + 1) % Threads[T].length] = ["N",SeptGet(DecGet(Threads[T][(i + 1) % Threads[T].length]) + DecGet(Threads[T][(ind) % Threads[T].length]))]

						} 
					}

				}
			}
			if (Threads[T][i] == "A")
			{
				var go = false
				if (typeof Threads[T][(i - 1) % Threads[T].length] == "object")
				{
					if (Threads[T][(i - 1) % Threads[T].length][0] == "N")
					{
						go = true
					}
				}
				if (Threads[T][(i - 1) % Threads[T].length] < 7 || go)
				{
					var off = i
					for (var M = 0; M < Threads[T].length; M++)
					{
						if (Threads[T][(M + off) % Threads[T].length] < 7)
						{
							Threads[T][(M + off) % Threads[T].length] = DecGet(Threads[T][(M + off) % Threads[T].length]) + DecGet(Threads[T][(i - 1) % Threads[T].length])
							M = Threads[T].length + 5;
						}
						if (typeof Threads[T][(M + off) % Threads[T].length] == "object")
						{
							if (Threads[T][(M + off) % Threads[T].length][0] == "N")
							{
					
								Threads[T][(M + off) % Threads[T].length] = ["N",SeptGet(DecGet(Threads[T][(M + off) % Threads[T].length]) + DecGet(Threads[T][(i - 1) % Threads[T].length]))]
								M = Threads[T].length + 5;
							}
						}
							
					}
				}
			}
			if (Threads[T][i] == "C")//move from below to nearest X cell
			{	indexToCopy = i % Threads[(T+1) % Threads.length].length
				copied = Threads[(T+1) % Threads.length][indexToCopy]
				off = Indexes[T]
				for (var M = 0; M < Threads[T].length; M++)
				{
					if (Threads[T][(M + off) % Threads[T].length] == "X")
					{
						Threads[T][(M + off) % Threads[T].length] = copied;
						M = Threads[T].length + 1;
					}	
				}
			}
			if (Threads[T][i] == "p")//move from behind to nearest X cell
			{	
				ind = i - 1
				if (ind < 0)
				{
					ind = ind + Threads[T].length
				}
				toCopy = Threads[T][ind %  Threads[T].length]
				off = i
				for (var M = 0; M < Threads[T].length; M++)
				{
					if (Threads[T][(M + off) % Threads[T].length] == "X")
					{
						Threads[T][(M + off) % Threads[T].length] = toCopy;
						M = Threads[T].length + 1;
					}	
				}
			}
			if (Threads[T][i] == "c")//move from below to nearest X cell
			{
				
			}
			Indexes[T] = Indexes[T] + 1
		}
		if (Indexes[T] > Threads[T].length - 1)
		{
			Indexes[T] = Indexes[T] % Threads[T].length
		}	
		if (done)
		{
			RemoveThese.push(T)
		}
	}
	for (var i = 0; i < RemoveThese.length; i++)
	{
		Indexes.splice(RemoveThese[i],1)
		Threads.splice(RemoveThese[i],1)
	}
}
function AddThread()
{
	x = prompt("Enter Script","1E").split('');
	Out = []
	CurrentlyAdding = []
	bracketnesting = false;
	console.log("length:"+x.length)
	for (var i = 0; i < x.length; i++)
	{	
		console.log(x[i])
		if (x[i] == "]" && bracketnesting)
		{
			bracketnesting = false
			CurrentlyAdding = ["N",CurrentlyAdding]
			Out.push(CurrentlyAdding)
			CurrentlyAdding = []
		}
		else if (bracketnesting == true)
		{
			CurrentlyAdding.push(x[i])
		}
		else if (x[i] == "[" && i < x.length)
		{
			bracketnesting = true
		}
		else
		{
			Out.push(x[i]);
		}
	}
	Threads.push(Out)
	Indexes.push(0)
}
AddThread()
function draw() {
	canvas.fillStyle = "#ffffff"
	canvas.fillRect(0,0,screen.width,screen.height);
	canvas.fillStyle = "#000000"
	canvas.shadowBlur = 2
	for (var i = 0; i < Threads.length; i++)
	{	
		var xoffset = 0
		for (var I = 0; I < Threads[i].length; I++)
		{
			if (Indexes[i] == I)
			{
				canvas.fillText("|",Indexes[i]*10+5+xoffset,i*20+20)
				console.log(xoffset)
			}
			if (typeof Threads[i][I] == "object")
			{
				if (Threads[i][I][0] == "N")
				{
					canvas.fillText(("["+Threads[i][I][1]+"]").replace(/,/g, ''),I*10+5+xoffset,i*20+10)
					xoffset = xoffset + 3 + 5 * DecGet(Threads[i][I][1]).toString().length
				}
			}
			else
			{
				canvas.fillText(Threads[i][I],I*10+5+xoffset,i*20+10)
			}
		}
	}
}


</script>